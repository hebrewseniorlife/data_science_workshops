---
title: "Chapter 3 - Data Transformation using Tidyverse"
subtitle: "Mutate, Summarize, Gather & Spread - Time for some R magic spells"
date: "2019-04-05 (updated `r Sys.Date()`)"
output: 
  html_document:
    theme: cosmo
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: true
      print: false
---

[< Back to Index](/)

`Tidyverse` is a collection of 8 awesome R packages, including:

- `dplyr`: Data manipulation (Chapter 3)
- `tidyr`: Data Long/Wide Transformation (Chapter 3)
- `purrr`: List-based manipulation (Chapter 3)
- `tibble`: Improved version of data.frame (Chapter 1)
- `readr`: Improved data reading methods (Chapter 2)
- `stringr`: String Operations using regular expression
- `forcats`: Categorical Analyses
- `ggplot2`: Data Visualizations with a set of grammar (Chapter 5)

In this chapter, we will talk about data transformation and will focus on `dplyr` and `tidyr`. We will also give a basic introduction to list-based analyses using `purrr`. As we continue forward in this training, we will discuss the other packages mentioned above. 

```{r, include = F}
library(tidyverse)
library(kableExtra)
```

# `dplyr` for data manipulation
Data manipulation refers to most common analtyic tasks including adding or droping columns or rows, generating summary statistics and implementing conditional logics for columns. 

`dplyr` comes with a set of "data manipulation verbs" that can natually express nearly all data manipulation tasks in English. This design makes it very easy to learn and communicate in this language and is one of the biggest reasons why people use R. In the following section, we will start by showing you a quick example (we will use this example multiple times in the future) followed by a detailed explanation of some of the most useful pieces of `dplyr`. We will also have a few hands-on exercises to highlight the practicality of this package. 

## Getting Started
In this example, we will use the `starwars` dataset, which is attached in `dplyr`. You need to load either `dplyr` or `tidyverse` to be able to access the dataset. You can type `View(starwars)` in your R console to make sure you can access it. Here is a screenshot of what this dataset looks like. 

![](images/starwars.png)

### Q1: What's the average height for all characters in Star Wars?
We know that we have a `mean()` function inside base R. The `na.rm = T` option within this function specifies how to deal with `NA`(missing) values: here we want to remove ("rm") them 
```{r}.
mean(starwars$height, na.rm = T)
```

We can also use `dplyr` to accomplish the same thing. In `dplyr` we have a `summarize` function, which generates many summary statistics. It is important to remember that **`summarize` always generates a new data frame**.
```{r}
starwars %>%
  summarize(mean_height = mean(height, na.rm = T))
```

Now is a good time to introduce the concept of 'piping' in R. Mainly used by `tidyverse` packages but also adopted by a lot of others, piping or `%>%` is simply a structure that makes your code more readable. Technically, the `%>%` symbol does nothing but **send the result on the left to the next function as its first argument**. 

### Q2: What's the average height for all human characters in Star Wars?

In Base R, we can use:
```{r}
mean(starwars[starwars$species == "Human", "height"], na.rm = T)
```

With `dplyr`, we use a `filter`. The `filter` function selects out every row that fits the positive condition. 
```{r}
starwars %>%
  filter(species == "Human") %>%
  summarize(
    mean_height = mean(height, na.rm = T)
  )
```

### Q3: What's the mean and stand deviation of height for all human characters who have yellow eyes?
In Base R, we can use: 
```{r}
mean(starwars[starwars$species == "Human" & starwars$eye_color == "yellow", ]$height, 
     na.rm = T)
sd(starwars[starwars$species == "Human" & starwars$eye_color == "yellow", ]$height, 
   na.rm = T)
```

In `dplyr`, it is easier to deal with more complicated situations. 

```{r}
starwars %>%
  filter(species == "Human" & eye_color == "yellow") %>%
  summarise(
    mean_height = mean(height, na.rm = T),
    sd_height = sd(height, na.rm = T)
  )
```

### Q4: What's the mean and stand deviation of height in all species?
Base R, we can use the `aggregate` function, but the syntax is difficult to understand.
```{r}
aggregate(starwars$height, by = list(starwars$species), FUN = function(x) {
  c(mean = mean(x, na.rm = T), sd = sd(x, na.rm = T))
})
```

With `dplyr`, we will use the very powerful, and easy to understand, `group_by` function. 
```{r}
starwars %>%
  group_by(species) %>%
  summarise(
    mean_height = mean(height, na.rm = T),
    sd_height = sd(height, na.rm = T)
  )
```

### Quick Exercise

#### What are the average weights for all humans stratified by sex?

## `dplyr` Verbs
### `select`
`select` picks out columns by names or index.
```{r}
starwars %>%
  select(name:mass, gender, 9)
```

You can use the `-` negative sign to indicate that you don't want certain column(s).
```{r}
starwars %>%
  select(-(3:13))
```

There are also a few helper functions in `dplyr` that can help you quickly select out columns that fit your criteria. 

```{r}
starwars %>%
  select(contains("color"))
```

### `filter`
`filter` will select out rows that fit certain criteria. It takes regular logical expressions in R and you can connect multiple expressions together with `&`(and) or `|`(or). Check [Chapter 1](/01_getting_started.html#control_statements) for details. 

```{r}
starwars %>%
  filter(eye_color == "red") %>%
  select(name, eye_color)
```

### `slice`
`slice` is a wrapper function of a special use case of `filter`: `filter(row_number() == something)`. It works in a similar way as `select`. It's mostly useful when you combine it with `group_by`. The example below will select out the first row in every eye_color. 

```{r}
starwars %>%
  group_by(eye_color) %>%
  slice(1) %>%
  select(1:2)
```

### `mutate`
The `mutate` function can be used to add new columns or to change existing columns. A common usage is to combine `mutate` with `ifelse` to make conditional values. 
```{r}
starwars %>%
  mutate(
    human_gender = ifelse(species == "Human", gender, NA)
  ) %>%
  select(name, gender, human_gender, species) %>%
  slice(10:20)
```

### `summarize`
New users often mix up `mutate` and `summarize`. The main difference is that `mutate` works in the original data frame while `summarize` generates a new one. 

### `group_by`
The `group_by` function puts an "attribute" on the data frame. 'group_by' does not change the contents of the data frame, but when you send this data frame to other `dplyr` functions, those functions will know that you want the actions to be done by groups. We can check the grouping information using `attributes()`.

```{r}
starwars %>%
  group_by(gender, species) %>%
  attributes()
```

### `join`
In many cases, we need to merge two data frames. R's native `merge` function works but `dplyr`'s `join` functions are much better. There are 4 join functions that are frequently used: `left_join`, `right_join`, `full_join` and `inner_join`. See [this page](https://stat545.com/bit001_dplyr-cheatsheet.html) for details. 

![](images/join-venn.png)

## Exercises
We might not have enough time to go through the following exercises during the workshop but it's highly recommended for you to find a time and go through these exercises and make sure you really understand the concepts. These exercises are from the STATS 545 class from UBC (Canada). You are also recommended to read their [`dplyr` tutorial](https://stat545.com/block009_dplyr-intro.html), which is also well written. 

http://stat545.com/Classroom/notes/cm005-exercise.nb.html

# Tidy data
One of the greatest contributions of `tidyverse` is that it provides a theory for a standardized way to organize values within a dataset. In Hadley's 2014 [tidy data](https://www.jstatsoft.org/article/view/v059i10/v59i10.pdf) paper, he summarizes the principles of a tidy data:

1. Each variable forms a column.
2. Each observation forms a row.
3. Each type of observational unit forms a table

Let's take a look at the following 5 sets of tables. Despite the very different structures, these tables represent the same information. How can we describe the transformations among these formats?

```{r, echo=FALSE}
sable <- function(x, y) kable_styling(kable(x, caption = y), "condensed", full_width = F)

tbl1 <- sable(table1, "table1")
tbl2 <- sable(table2, "table2")
tbl3 <- sable(table3, "table3")
tbl4a <- sable(table4a, "table4a")
tbl4b <- sable(table4b, "table4b")
tbl5 <- sable(table5, "table5")

library(htmltools)
library(shiny)
fluidRow(
  column(4, HTML(tbl1)),
  column(4, HTML(tbl3)),
  column(4, HTML(tbl4a, tbl4b))
) 

fluidRow(
  column(6, HTML(tbl2)),
  column(6, HTML(tbl5))
) 
```


(You can find these 5 example tables in the `tidyr` package, which is included in `tidyverse`.)

In the tidy data paper, Hadley quoted Leo Tolstoy's words "Happy families are all alike; every unhappy family is unhappy in its own way." and commented

> Like families, tidy datasets are all alike but every messy dataset is messy in its own way.

The concepts of `tidy data` is a theory of good practice. In fact, if you are an experienced data analyst from other languages, you already know the importance of keeping your data and programming 'tidy'. This concept gives a name to what we often called "experience"  and a set of verbs to decribe the action of transformation among these formats. In R, these actions are performed via four verbs from `tidyr` package, namely `gather`, `spread`, `separate` and `unite`. 

# tidyr
One metaphor of tidying up a dataset could be playing with sand. When you try to hold the sand with your hand, the sand `gather`s together and becomes tall and narrow. When you smash the sand with your fist, it `spread`s out and becomes thin and wide.

- gather: wide to tall
- spread: tall to wide
- separate: separate *ONE* multi-info column into *multiple* columns
- unite: unite *multiple* columns into *one* column

Let's create a messy dataset and use it as an example. Here, we are simulating an observational study with only 2 questions and 3 visits. The original creator of this dataset is not familiar with tidy data so he organized the data in a very untidy way.

```{r}
library(tidyverse)
library(rmarkdown) # for paged_table
messy_dt <- tibble(
  id = c(1, 2, 3),
  test1_v1 = sample(100, 3),
  test1_v2 = sample(100, 3),
  test1_v3 = sample(100, 3),
  test2_v1 = sample(100, 3),
  test2_v2 = sample(100, 3),
  test2_v3 = sample(100, 3)
) 

messy_dt

```


`gather` collects data from all specified columns (if not specified, all columns) and turned them from columns to rows. Column names go to the "key" column while values go to the "value" column. 

```{r}
gather(messy_dt, key = "key", value = "value")
```

In this example, all the data from the original data frame is arranged in these two columns, `key` & `value`. Both columns are newly generated. The `key` column includes all the previous column names while the `value` column includes all the numbers. However, this is not very helpful in this case because it treats the `id` column as a regular data column while it should have been left outside of the operation. Therefore, we need to instruct `gather` to include the correct variables in the transformation (or to exclude what should not be included). You can do that by putting column names after the `value` argument. You can also choose to put the column names that you don't want after a minus sign. Similar to numeric vectors (Chapter 1), `:` here means "to" in English. `test1_v1:test2_v3` means every column between `test1_v1` and `test2_v3`. 


```{r}
gather(messy_dt, "var", "value", test1_v1:test2_v3)
# equivalent to
# gather(messy_dt, "var", "value", -id)
# gather(messy_dt, "var, "value", test1_v1, test1_v2, test1_v3, test2_v1,
#        test2_v2, test2_v3)
```


# [< Back to Index](/)
